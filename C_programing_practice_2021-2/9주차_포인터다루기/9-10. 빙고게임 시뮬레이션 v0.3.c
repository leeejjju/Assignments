#include <stdio.h>
/*8-10 문제의 업그레이드를 진행하라.
주요 내용 : 5*5 크기의 2차원 배열인 bingo를 25 크기의 1차원 배열로 변경한다.

5*5 크기의 빙고게임을 진행하는 모습을 간단하게 시뮬레이션 하려고 한다. 빙고 매트릭스의 처음값은 모두 0이다.

8-10번에서 제작하였던 markBingo()라는 함수와 printBingo() 함수를 1차원 배열 사용하도록 업그레이드하라.

동작내용은 동일하다.

즉 이 함수에서는 선택된 칸의 번호에 대해서 검사하고 마크하는 작업을 수행한 후, 빙고가 완성되었는지 확인하여 그 결과를 리턴하는 작업을 수행한다. 이때, 빙고가 완성되었다는 것은 5개 중 1개의 줄 또는 1개의 열에 해당되는 5개 의 칸이 모두 1로 마크된 경우를 말한다.*/

int markbingo(int num, int b[]);
//파라미터 : 선택된 칸번호(num), 빙고매트릭스(b)
//리턴값 : 이미 마크되어 있었음 0, 
//       마크 안되어 마크하였는데 빙고 완성됨 1,  
//       마크 안되어 마크하였는데 빙고는 미완성 -1,  
//수행내용 : 현재의 빙고매트릭스에 선택된 칸번호에 해당되는
//         칸 검사한 후 마크함
void printBingo(int b[]);
//파라미터 : 빙고매트릭스(b)
//리턴값 : 없음 
//수행내용 : 현재의 빙고매트릭스 내용 표현

int main(void) {
	int bingo[25]={0}; // 빙고용 매트릭스
  int num;

  while(1){ //1-25 밖의 숫자가 나올때까지 반복 

    printf("Enter a number(1~25) > ");
    scanf("%d", &num);
    if(num > 25 || num <= 1){
      printf("EXIT!");
      break;
    }

    if (markBingo(num, bingo) == 0){ //마크빙고함수 실행, 방금 입력한 num이 중복이라면 중복문구 출력 
      printf("중복!\n");
    }else if(markBingo(num, bingo) == 1){ //빙고 다됐다카면 빙고!외치고 루프 탈출 
      printf("빙고!\n");
      break;
    }
  }

  printBingo(bingo); //탈출후에는 현재 빙고상태 출력 
  return 0;
}

int markbingo(int num, int b[]){
  int mark = 1, bing = 1;
  int i, j;

  if(b[num-1] == 0){ //비어있는 칸인가?
      b[num-1] = 1; //채우기
  }else{ //이미 차있는 칸인가? 
      mark = 0; //중복입력받았다는 뜻 
    }

  if(mark == 1){ //방금 입력된놈이 중복이 아니라면, 빙고검사 시작 

    for(i = 0; i < 5; i++){ //세로열 검사 
      bing = 1; //희망을 가지고 시작 
      for(j = i*1; j < i+21; j += 5){
        if(b[j] == 0){ //하나라도 채워져있지 않다면 
          bing = 0; //해당 행 나가리 
          break;
        }
      }
      if(bing == 1){ //한 패턴동안 1이 유지되었으면 빙고 
        return 1;
      }
    }

    for(j = 0; j < 21; j += 5){ //가로열 검사 
      bing = 1; //희망을 가지고 시작 
      for(i = j; i < j+5; i++){
        if(b[i] == 0){
          bing = 0;
          break;
        }
      }
      if(bing == 1){ //한 패턴동안 1이 유지되었으면 빙고 
        return 1;
      }
    }

    bing = 1; //희망을 가지고 시작 
    for(i = 0; i < 25; i += 6){ // '\'대각선 검사 
      if(b[i] == 0){
        bing = 0;
        break;
      }
    }
    if(bing == 1){ //검사동안 1이 유지되었으면 빙고 
        return 1;
    }

    bing = 1; //희망을 가지고 시작 
    for(i = 0; i < 5; i += 4){ // '/'대각선 검사 
      if(b[i] == 0){
        bing = 0;
        break;
      }
    }
    if(bing == 1){ //검사동안 1이 유지되었으면 빙고 
        return 1;
    }
    
    return -1; //전부 어림도없었으면 빙고 아니라는 의미로 -1 리턴 

  }
  return mark; //아니면 중복이라는 의미로 0 리턴 

}
//파라미터 : 선택된 칸번호(num), 빙고매트릭스(b)
//리턴값 : 이미 마크되어 있었음 0, 
//       마크 안되어 마크하였는데 빙고 완성됨 1,  
//       마크 안되어 마크하였는데 빙고는 미완성 -1,  
//수행내용 : 현재의 빙고매트릭스에 선택된 칸번호에 해당되는
//         칸 검사한 후 마크함

void printBingo(int b[]){
  int i, stack = 0;

  printf("\nBINGO MATRIX\n---------------------\n|");
  for(i = 0; i < 25; i ++){
    printf(" %d |", b[i]);
    stack ++;
    if(stack > 4){
      if(i != 24){
        printf("\n---------------------\n|"); //줄바꿈 
      }else{
        printf("\n---------------------\n"); //줄바꿈 
      }
      stack = 0; //스택초기화 
    }
  }
  //쭉 출력하되 5의배수..이전..? 아니다 스택이 다섯개 쌓이면 엔터와 줄치고 스텍초기화 ㅎ자ㅏ 

  return;
}


